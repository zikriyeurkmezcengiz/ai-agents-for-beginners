<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "d3ceafa2939ede602b96d6bd412c5cbf",
  "translation_date": "2025-03-28T14:09:57+00:00",
  "source_file": "02-explore-agentic-frameworks\\README.md",
  "language_code": "tw"
}
-->
[![æ¢ç´¢ AI ä»£ç†æ¡†æ¶](../../../translated_images/lesson-2-thumbnail.807a3a4fc57057096d10678bf84638d17d50c50239014e75a7708731a33bb802.tw.png)](https://youtu.be/ODwF-EZo_O8?si=1xoy_B9RNQfrYdF7)

> _(é»æ“Šä¸Šæ–¹åœ–ç‰‡è§€çœ‹æœ¬èª²ç¨‹å½±ç‰‡)_

# æ¢ç´¢ AI ä»£ç†æ¡†æ¶

AI ä»£ç†æ¡†æ¶æ˜¯å°ˆé–€è¨­è¨ˆç”¨ä¾†ç°¡åŒ– AI ä»£ç†å‰µå»ºã€éƒ¨ç½²å’Œç®¡ç†çš„è»Ÿé«”å¹³å°ã€‚é€™äº›æ¡†æ¶ç‚ºé–‹ç™¼è€…æä¾›é å»ºçš„çµ„ä»¶ã€æŠ½è±¡å±¤åŠå·¥å…·ï¼Œä»¥ç°¡åŒ–è¤‡é›œ AI ç³»çµ±çš„é–‹ç™¼ã€‚

é€éæä¾›æ¨™æº–åŒ–çš„æ–¹æ³•ä¾†è§£æ±º AI ä»£ç†é–‹ç™¼ä¸­çš„å¸¸è¦‹æŒ‘æˆ°ï¼Œé€™äº›æ¡†æ¶å¹«åŠ©é–‹ç™¼è€…å°ˆæ³¨æ–¼æ‡‰ç”¨ç¨‹å¼çš„ç¨ç‰¹æ–¹é¢ï¼ŒåŒæ™‚æå‡ç³»çµ±çš„å¯æ“´å±•æ€§ã€å¯è¨ªå•æ€§å’Œæ•ˆç‡ã€‚

## ä»‹ç´¹

æœ¬èª²ç¨‹å°‡æ¶µè“‹ï¼š

- ä»€éº¼æ˜¯ AI ä»£ç†æ¡†æ¶ï¼Ÿå®ƒèƒ½å¹«åŠ©é–‹ç™¼è€…å¯¦ç¾å“ªäº›ç›®æ¨™ï¼Ÿ
- åœ˜éšŠå¦‚ä½•ä½¿ç”¨é€™äº›æ¡†æ¶å¿«é€ŸåŸå‹è¨­è¨ˆã€è¿­ä»£åŠæå‡ä»£ç†èƒ½åŠ›ï¼Ÿ
- å¾®è»Ÿæ‰€å‰µå»ºçš„æ¡†æ¶å’Œå·¥å…·ä¹‹é–“æœ‰ä½•å·®ç•°ï¼Ÿ
- æˆ‘å¯ä»¥ç›´æ¥æ•´åˆç¾æœ‰çš„ Azure ç”Ÿæ…‹ç³»çµ±å·¥å…·ï¼Œé‚„æ˜¯éœ€è¦ç¨ç«‹çš„è§£æ±ºæ–¹æ¡ˆï¼Ÿ
- ä»€éº¼æ˜¯ Azure AI Agents æœå‹™ï¼Œå®ƒèƒ½å¦‚ä½•å¹«åŠ©æˆ‘ï¼Ÿ

## å­¸ç¿’ç›®æ¨™

æœ¬èª²ç¨‹çš„ç›®æ¨™æ˜¯å¹«åŠ©ä½ äº†è§£ï¼š

- AI ä»£ç†æ¡†æ¶åœ¨ AI é–‹ç™¼ä¸­çš„è§’è‰²ã€‚
- å¦‚ä½•åˆ©ç”¨ AI ä»£ç†æ¡†æ¶æ§‹å»ºæ™ºèƒ½ä»£ç†ã€‚
- AI ä»£ç†æ¡†æ¶æ‰€å•Ÿç”¨çš„é—œéµåŠŸèƒ½ã€‚
- AutoGenã€Semantic Kernel å’Œ Azure AI Agent Service çš„å·®ç•°ã€‚

## ä»€éº¼æ˜¯ AI ä»£ç†æ¡†æ¶ï¼Ÿå®ƒèƒ½å¹«åŠ©é–‹ç™¼è€…å¯¦ç¾å“ªäº›ç›®æ¨™ï¼Ÿ

å‚³çµ±çš„ AI æ¡†æ¶å¯ä»¥å¹«åŠ©ä½ å°‡ AI æ•´åˆåˆ°æ‡‰ç”¨ç¨‹å¼ä¸­ï¼Œä¸¦ä½¿é€™äº›æ‡‰ç”¨ç¨‹å¼è®Šå¾—æ›´å¥½ï¼š

- **å€‹æ€§åŒ–**ï¼šAI å¯ä»¥åˆ†æä½¿ç”¨è€…è¡Œç‚ºå’Œåå¥½ï¼Œæä¾›å€‹æ€§åŒ–çš„æ¨è–¦ã€å…§å®¹å’Œé«”é©—ã€‚
  ç¯„ä¾‹ï¼šåƒ Netflix é€™æ¨£çš„ä¸²æµæœå‹™ä½¿ç”¨ AI æ ¹æ“šè§€çœ‹æ­·å²æ¨è–¦é›»å½±å’Œç¯€ç›®ï¼Œæå‡ä½¿ç”¨è€…çš„åƒèˆ‡åº¦å’Œæ»¿æ„åº¦ã€‚
- **è‡ªå‹•åŒ–å’Œæ•ˆç‡**ï¼šAI å¯ä»¥è‡ªå‹•åŒ–é‡è¤‡æ€§ä»»å‹™ã€ç°¡åŒ–å·¥ä½œæµç¨‹ä¸¦æå‡é‹ç‡Ÿæ•ˆç‡ã€‚
  ç¯„ä¾‹ï¼šå®¢æˆ¶æœå‹™æ‡‰ç”¨ç¨‹å¼ä½¿ç”¨ AI é©…å‹•çš„èŠå¤©æ©Ÿå™¨äººè™•ç†å¸¸è¦‹æŸ¥è©¢ï¼Œç¸®çŸ­éŸ¿æ‡‰æ™‚é–“ä¸¦è®“äººé¡ä»£ç†å°ˆæ³¨æ–¼æ›´è¤‡é›œçš„å•é¡Œã€‚
- **æå‡ä½¿ç”¨è€…é«”é©—**ï¼šAI å¯ä»¥é€šéæä¾›æ™ºèƒ½åŠŸèƒ½ï¼ˆå¦‚èªéŸ³è­˜åˆ¥ã€è‡ªç„¶èªè¨€è™•ç†å’Œé æ¸¬æ–‡å­—ï¼‰ä¾†æ”¹å–„æ•´é«”ä½¿ç”¨è€…é«”é©—ã€‚
  ç¯„ä¾‹ï¼šåƒ Siri å’Œ Google Assistant é€™æ¨£çš„è™›æ“¬åŠ©ç†ä½¿ç”¨ AI ç†è§£ä¸¦å›æ‡‰èªéŸ³å‘½ä»¤ï¼Œè®“ä½¿ç”¨è€…æ›´è¼•é¬†åœ°èˆ‡è¨­å‚™äº’å‹•ã€‚

### è½èµ·ä¾†å¾ˆæ£’å°å§ï¼Œé‚£ç‚ºä»€éº¼é‚„éœ€è¦ AI ä»£ç†æ¡†æ¶ï¼Ÿ

AI ä»£ç†æ¡†æ¶ä¸åƒ…åƒ…æ˜¯ AI æ¡†æ¶ï¼Œå®ƒå€‘æ—¨åœ¨å‰µå»ºèƒ½èˆ‡ä½¿ç”¨è€…ã€å…¶ä»–ä»£ç†åŠç’°å¢ƒäº¤äº’ä»¥å¯¦ç¾ç‰¹å®šç›®æ¨™çš„æ™ºèƒ½ä»£ç†ã€‚é€™äº›ä»£ç†èƒ½è¡¨ç¾å‡ºè‡ªä¸»è¡Œç‚ºã€åšå‡ºæ±ºç­–ä¸¦é©æ‡‰ä¸æ–·è®ŠåŒ–çš„æ¢ä»¶ã€‚ä»¥ä¸‹æ˜¯ AI ä»£ç†æ¡†æ¶å•Ÿç”¨çš„ä¸€äº›é—œéµåŠŸèƒ½ï¼š

- **ä»£ç†å”ä½œèˆ‡å”èª¿**ï¼šæ”¯æŒå‰µå»ºå¤šå€‹ AI ä»£ç†ï¼Œè®“å®ƒå€‘èƒ½å…±åŒå·¥ä½œã€æºé€šä¸¦å”èª¿ä»¥è§£æ±ºè¤‡é›œä»»å‹™ã€‚
- **ä»»å‹™è‡ªå‹•åŒ–èˆ‡ç®¡ç†**ï¼šæä¾›æ©Ÿåˆ¶ä»¥è‡ªå‹•åŒ–å¤šæ­¥å·¥ä½œæµç¨‹ã€ä»»å‹™å§”æ´¾åŠä»£ç†é–“çš„å‹•æ…‹ä»»å‹™ç®¡ç†ã€‚
- **ä¸Šä¸‹æ–‡ç†è§£èˆ‡é©æ‡‰**ï¼šä½¿ä»£ç†å…·å‚™ç†è§£ä¸Šä¸‹æ–‡ã€é©æ‡‰ç’°å¢ƒè®ŠåŒ–ä¸¦æ ¹æ“šå³æ™‚ä¿¡æ¯åšå‡ºæ±ºç­–çš„èƒ½åŠ›ã€‚

ç¸½çµä¾†èªªï¼Œä»£ç†å¯ä»¥å¹«åŠ©ä½ åšå¾—æ›´å¤šï¼Œå°‡è‡ªå‹•åŒ–æå‡åˆ°æ–°çš„å±¤æ¬¡ï¼Œå‰µå»ºèƒ½é©æ‡‰ä¸¦å¾ç’°å¢ƒä¸­å­¸ç¿’çš„æ›´æ™ºèƒ½ç³»çµ±ã€‚

## å¦‚ä½•å¿«é€ŸåŸå‹è¨­è¨ˆã€è¿­ä»£åŠæå‡ä»£ç†èƒ½åŠ›ï¼Ÿ

é€™æ˜¯ä¸€å€‹å¿«é€Ÿè®ŠåŒ–çš„é ˜åŸŸï¼Œä½†å¤§å¤šæ•¸ AI ä»£ç†æ¡†æ¶ä¸­æœ‰ä¸€äº›å…±åŒé»å¯ä»¥å¹«åŠ©ä½ å¿«é€ŸåŸå‹è¨­è¨ˆå’Œè¿­ä»£ï¼ŒåŒ…æ‹¬æ¨¡çµ„åŒ–çµ„ä»¶ã€å”ä½œå·¥å…·åŠå³æ™‚å­¸ç¿’ã€‚è®“æˆ‘å€‘æ·±å…¥äº†è§£ï¼š

- **ä½¿ç”¨æ¨¡çµ„åŒ–çµ„ä»¶**ï¼šAI SDK æä¾›é å»ºçš„çµ„ä»¶ï¼Œä¾‹å¦‚ AI å’Œè¨˜æ†¶é«”é€£æ¥å™¨ã€ä½¿ç”¨è‡ªç„¶èªè¨€æˆ–ä»£ç¢¼æ’ä»¶é€²è¡ŒåŠŸèƒ½èª¿ç”¨ã€æç¤ºæ¨¡æ¿ç­‰ã€‚
- **åˆ©ç”¨å”ä½œå·¥å…·**ï¼šè¨­è¨ˆå…·æœ‰ç‰¹å®šè§’è‰²å’Œä»»å‹™çš„ä»£ç†ï¼Œæ¸¬è©¦ä¸¦å®Œå–„å”ä½œå·¥ä½œæµç¨‹ã€‚
- **å³æ™‚å­¸ç¿’**ï¼šå¯¦æ–½åé¥‹è¿´è·¯ï¼Œä½¿ä»£ç†å¾äº¤äº’ä¸­å­¸ç¿’ä¸¦å‹•æ…‹èª¿æ•´è¡Œç‚ºã€‚

### ä½¿ç”¨æ¨¡çµ„åŒ–çµ„ä»¶

åƒ Microsoft Semantic Kernel å’Œ LangChain çš„ SDK æä¾›äº†é å»ºçš„çµ„ä»¶ï¼Œä¾‹å¦‚ AI é€£æ¥å™¨ã€æç¤ºæ¨¡æ¿å’Œè¨˜æ†¶é«”ç®¡ç†ã€‚

**åœ˜éšŠå¦‚ä½•ä½¿ç”¨é€™äº›**ï¼šåœ˜éšŠå¯ä»¥å¿«é€Ÿçµ„è£é€™äº›çµ„ä»¶ä»¥å‰µå»ºåŠŸèƒ½æ€§åŸå‹ï¼Œè€Œç„¡éœ€å¾é ­é–‹å§‹ï¼Œå¾è€Œå¯¦ç¾å¿«é€Ÿå¯¦é©—å’Œè¿­ä»£ã€‚

**å¯¦éš›æ“ä½œå¦‚ä½•é‹ä½œ**ï¼šä½ å¯ä»¥ä½¿ç”¨é å»ºçš„è§£æå™¨å¾ä½¿ç”¨è€…è¼¸å…¥ä¸­æå–ä¿¡æ¯ï¼Œä½¿ç”¨è¨˜æ†¶é«”æ¨¡çµ„å­˜å„²å’Œæª¢ç´¢æ•¸æ“šï¼Œä¸¦ä½¿ç”¨æç¤ºç”Ÿæˆå™¨èˆ‡ä½¿ç”¨è€…äº¤äº’ï¼Œç„¡éœ€å¾é ­æ§‹å»ºé€™äº›çµ„ä»¶ã€‚

**ç¯„ä¾‹ä»£ç¢¼**ã€‚ä»¥ä¸‹æ˜¯ä½¿ç”¨ Semantic Kernel Python å’Œ .Net çš„é å»º AI é€£æ¥å™¨é€²è¡Œè‡ªå‹•åŠŸèƒ½èª¿ç”¨ä»¥å›æ‡‰ä½¿ç”¨è€…è¼¸å…¥çš„ç¯„ä¾‹ï¼š

``` python
# Semantic Kernel Python Example

import asyncio
from typing import Annotated

from semantic_kernel.connectors.ai import FunctionChoiceBehavior
from semantic_kernel.connectors.ai.open_ai import AzureChatCompletion, AzureChatPromptExecutionSettings
from semantic_kernel.contents import ChatHistory
from semantic_kernel.functions import kernel_function
from semantic_kernel.kernel import Kernel

# Define a ChatHistory object to hold the conversation's context
chat_history = ChatHistory()
chat_history.add_user_message("I'd like to go to New York on January 1, 2025")


# Define a sample plugin that contains the function to book travel
class BookTravelPlugin:
    """A Sample Book Travel Plugin"""

    @kernel_function(name="book_flight", description="Book travel given location and date")
    async def book_flight(
        self, date: Annotated[str, "The date of travel"], location: Annotated[str, "The location to travel to"]
    ) -> str:
        return f"Travel was booked to {location} on {date}"

# Create the Kernel
kernel = Kernel()

# Add the sample plugin to the Kernel object
kernel.add_plugin(BookTravelPlugin(), plugin_name="book_travel")

# Define the Azure OpenAI AI Connector
chat_service = AzureChatCompletion(
    deployment_name="YOUR_DEPLOYMENT_NAME", 
    api_key="YOUR_API_KEY", 
    endpoint="https://<your-resource>.azure.openai.com/",
)

# Define the request settings to configure the model with auto-function calling
request_settings = AzureChatPromptExecutionSettings(function_choice_behavior=FunctionChoiceBehavior.Auto())


async def main():
    # Make the request to the model for the given chat history and request settings
    # The Kernel contains the sample that the model will request to invoke
    response = await chat_service.get_chat_message_content(
        chat_history=chat_history, settings=request_settings, kernel=kernel
    )
    assert response is not None

    """
    Note: In the auto function calling process, the model determines it can invoke the 
    `BookTravelPlugin` using the `book_flight` function, supplying the necessary arguments. 
    
    For example:

    "tool_calls": [
        {
            "id": "call_abc123",
            "type": "function",
            "function": {
                "name": "BookTravelPlugin-book_flight",
                "arguments": "{'location': 'New York', 'date': '2025-01-01'}"
            }
        }
    ]

    Since the location and date arguments are required (as defined by the kernel function), if the 
    model lacks either, it will prompt the user to provide them. For instance:

    User: Book me a flight to New York.
    Model: Sure, I'd love to help you book a flight. Could you please specify the date?
    User: I want to travel on January 1, 2025.
    Model: Your flight to New York on January 1, 2025, has been successfully booked. Safe travels!
    """

    print(f"`{response}`")
    # Example AI Model Response: `Your flight to New York on January 1, 2025, has been successfully booked. Safe travels! âœˆï¸ğŸ—½`

    # Add the model's response to our chat history context
    chat_history.add_assistant_message(response.content)


if __name__ == "__main__":
    asyncio.run(main())
```
```csharp
// Semantic Kernel C# example

using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.ChatCompletion;
using System.ComponentModel;
using Microsoft.SemanticKernel.Connectors.AzureOpenAI;

ChatHistory chatHistory = [];
chatHistory.AddUserMessage("I'd like to go to New York on January 1, 2025");

var kernelBuilder = Kernel.CreateBuilder();
kernelBuilder.AddAzureOpenAIChatCompletion(
    deploymentName: "NAME_OF_YOUR_DEPLOYMENT",
    apiKey: "YOUR_API_KEY",
    endpoint: "YOUR_AZURE_ENDPOINT"
);
kernelBuilder.Plugins.AddFromType<BookTravelPlugin>("BookTravel"); 
var kernel = kernelBuilder.Build();

var settings = new AzureOpenAIPromptExecutionSettings()
{
    FunctionChoiceBehavior = FunctionChoiceBehavior.Auto()
};

var chatCompletion = kernel.GetRequiredService<IChatCompletionService>();

var response = await chatCompletion.GetChatMessageContentAsync(chatHistory, settings, kernel);

/*
Behind the scenes, the model recognizes the tool to call, what arguments it already has (location) and (date)
{

"tool_calls": [
    {
        "id": "call_abc123",
        "type": "function",
        "function": {
            "name": "BookTravelPlugin-book_flight",
            "arguments": "{'location': 'New York', 'date': '2025-01-01'}"
        }
    }
]
*/

Console.WriteLine(response.Content);
chatHistory.AddMessage(response!.Role, response!.Content!);

// Example AI Model Response: Your flight to New York on January 1, 2025, has been successfully booked. Safe travels! âœˆï¸ğŸ—½

// Define a plugin that contains the function to book travel
public class BookTravelPlugin
{
    [KernelFunction("book_flight")]
    [Description("Book travel given location and date")]
    public async Task<string> BookFlight(DateTime date, string location)
    {
        return await Task.FromResult( $"Travel was booked to {location} on {date}");
    }
}
```

å¾é€™å€‹ç¯„ä¾‹ä¸­å¯ä»¥çœ‹åˆ°ï¼Œä½ å¦‚ä½•åˆ©ç”¨é å»ºçš„è§£æå™¨å¾ä½¿ç”¨è€…è¼¸å…¥ä¸­æå–é—œéµä¿¡æ¯ï¼Œä¾‹å¦‚èˆªç­é è¨‚è«‹æ±‚çš„èµ·é»ã€ç›®çš„åœ°å’Œæ—¥æœŸã€‚é€™ç¨®æ¨¡çµ„åŒ–æ–¹æ³•è®“ä½ èƒ½å°ˆæ³¨æ–¼é«˜å±¤æ¬¡é‚è¼¯ã€‚

### åˆ©ç”¨å”ä½œå·¥å…·

åƒ CrewAIã€Microsoft AutoGen å’Œ Semantic Kernel çš„æ¡†æ¶ä¿ƒé€²äº†å¤šå€‹ä»£ç†çš„å‰µå»ºï¼Œä½¿å®ƒå€‘èƒ½å…±åŒå·¥ä½œã€‚

**åœ˜éšŠå¦‚ä½•ä½¿ç”¨é€™äº›**ï¼šåœ˜éšŠå¯ä»¥è¨­è¨ˆå…·æœ‰ç‰¹å®šè§’è‰²å’Œä»»å‹™çš„ä»£ç†ï¼Œæ¸¬è©¦ä¸¦å®Œå–„å”ä½œå·¥ä½œæµç¨‹ï¼Œæå‡æ•´é«”ç³»çµ±æ•ˆç‡ã€‚

**å¯¦éš›æ“ä½œå¦‚ä½•é‹ä½œ**ï¼šä½ å¯ä»¥å‰µå»ºä¸€çµ„ä»£ç†ï¼Œæ¯å€‹ä»£ç†éƒ½æœ‰å°ˆé–€åŠŸèƒ½ï¼Œä¾‹å¦‚æ•¸æ“šæª¢ç´¢ã€åˆ†ææˆ–æ±ºç­–ã€‚é€™äº›ä»£ç†å¯ä»¥æºé€šä¸¦å…±äº«ä¿¡æ¯ä»¥é”æˆå…±åŒç›®æ¨™ï¼Œä¾‹å¦‚å›ç­”ä½¿ç”¨è€…æŸ¥è©¢æˆ–å®Œæˆä»»å‹™ã€‚

**ç¯„ä¾‹ä»£ç¢¼ï¼ˆAutoGenï¼‰**ï¼š

```python
# creating agents, then create a round robin schedule where they can work together, in this case in order

# Data Retrieval Agent
# Data Analysis Agent
# Decision Making Agent

agent_retrieve = AssistantAgent(
    name="dataretrieval",
    model_client=model_client,
    tools=[retrieve_tool],
    system_message="Use tools to solve tasks."
)

agent_analyze = AssistantAgent(
    name="dataanalysis",
    model_client=model_client,
    tools=[analyze_tool],
    system_message="Use tools to solve tasks."
)

# conversation ends when user says "APPROVE"
termination = TextMentionTermination("APPROVE")

user_proxy = UserProxyAgent("user_proxy", input_func=input)

team = RoundRobinGroupChat([agent_retrieve, agent_analyze, user_proxy], termination_condition=termination)

stream = team.run_stream(task="Analyze data", max_turns=10)
# Use asyncio.run(...) when running in a script.
await Console(stream)
```

åœ¨ä¹‹å‰çš„ä»£ç¢¼ä¸­ï¼Œä½ çœ‹åˆ°å¦‚ä½•å‰µå»ºä¸€å€‹ä»»å‹™ï¼Œæ¶‰åŠå¤šå€‹ä»£ç†å…±åŒåˆ†ææ•¸æ“šã€‚æ¯å€‹ä»£ç†åŸ·è¡Œç‰¹å®šåŠŸèƒ½ï¼Œä¸¦é€šéå”èª¿ä»£ç†ä¾†å®Œæˆæ‰€éœ€çš„çµæœã€‚é€šéå‰µå»ºå…·æœ‰å°ˆé–€è§’è‰²çš„ä»£ç†ï¼Œä½ å¯ä»¥æå‡ä»»å‹™æ•ˆç‡å’Œæ€§èƒ½ã€‚

### å³æ™‚å­¸ç¿’

é«˜ç´šæ¡†æ¶æä¾›å³æ™‚ä¸Šä¸‹æ–‡ç†è§£å’Œé©æ‡‰çš„èƒ½åŠ›ã€‚

**åœ˜éšŠå¦‚ä½•ä½¿ç”¨é€™äº›**ï¼šåœ˜éšŠå¯ä»¥å¯¦æ–½åé¥‹è¿´è·¯ï¼Œä½¿ä»£ç†å¾äº¤äº’ä¸­å­¸ç¿’ä¸¦å‹•æ…‹èª¿æ•´è¡Œç‚ºï¼Œå¾è€ŒæŒçºŒæ”¹é€²å’Œèƒ½åŠ›å®Œå–„ã€‚

**å¯¦éš›æ“ä½œå¦‚ä½•é‹ä½œ**ï¼šä»£ç†å¯ä»¥åˆ†æä½¿ç”¨è€…åé¥‹ã€ç’°å¢ƒæ•¸æ“šåŠä»»å‹™çµæœï¼Œä»¥æ›´æ–°å…¶çŸ¥è­˜åº«ã€èª¿æ•´æ±ºç­–ç®—æ³•ä¸¦éš¨æ™‚é–“æå‡æ€§èƒ½ã€‚é€™ç¨®è¿­ä»£å­¸ç¿’éç¨‹ä½¿ä»£ç†èƒ½é©æ‡‰è®ŠåŒ–çš„æ¢ä»¶å’Œä½¿ç”¨è€…åå¥½ï¼Œæå‡æ•´é«”ç³»çµ±æ•ˆèƒ½ã€‚

## AutoGenã€Semantic Kernel å’Œ Azure AI Agent Service ä¹‹é–“æœ‰ä»€éº¼ä¸åŒï¼Ÿ

æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥æ¯”è¼ƒé€™äº›æ¡†æ¶ï¼Œä½†è®“æˆ‘å€‘å¾è¨­è¨ˆã€åŠŸèƒ½å’Œç›®æ¨™ä½¿ç”¨æ¡ˆä¾‹çš„è§’åº¦ä¾†çœ‹çœ‹ä¸€äº›é—œéµå·®ç•°ï¼š
æ¨¡çµ„åŒ–ã€å”ä½œã€æµç¨‹ç·¨æ’ | å®‰å…¨ã€å¯æ“´å±•ä¸”éˆæ´»çš„ AI ä»£ç†éƒ¨ç½² | é€™äº›æ¡†æ¶çš„ç†æƒ³ä½¿ç”¨æ¡ˆä¾‹æ˜¯ä»€éº¼ï¼Ÿ

## æˆ‘å¯ä»¥ç›´æ¥æ•´åˆç¾æœ‰çš„ Azure ç”Ÿæ…‹ç³»çµ±å·¥å…·ï¼Œé‚„æ˜¯éœ€è¦ç¨ç«‹è§£æ±ºæ–¹æ¡ˆï¼Ÿ

ç­”æ¡ˆæ˜¯è‚¯å®šçš„ï¼Œä½ å¯ä»¥ç›´æ¥å°‡ç¾æœ‰çš„ Azure ç”Ÿæ…‹ç³»çµ±å·¥å…·æ•´åˆåˆ° Azure AI Agent Service ä¸­ï¼Œç‰¹åˆ¥æ˜¯å› ç‚ºå®ƒè¢«è¨­è¨ˆç‚ºèˆ‡å…¶ä»– Azure æœå‹™ç„¡ç¸«å”ä½œã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥æ•´åˆ Bingã€Azure AI Search å’Œ Azure Functionsã€‚å®ƒé‚„èˆ‡ Azure AI Foundry æœ‰æ·±åº¦æ•´åˆã€‚

å°æ–¼ AutoGen å’Œ Semantic Kernelï¼Œä½ ä¹Ÿå¯ä»¥èˆ‡ Azure æœå‹™æ•´åˆï¼Œä½†å¯èƒ½éœ€è¦å¾ä»£ç¢¼ä¸­èª¿ç”¨ Azure æœå‹™ã€‚å¦ä¸€ç¨®æ•´åˆæ–¹å¼æ˜¯ä½¿ç”¨ Azure SDKsï¼Œè®“ä½ çš„ä»£ç†èˆ‡ Azure æœå‹™äº’å‹•ã€‚æ­¤å¤–ï¼Œå¦‚å‰æ‰€è¿°ï¼Œä½ å¯ä»¥ä½¿ç”¨ Azure AI Agent Service ä½œç‚º AutoGen æˆ– Semantic Kernel ä¸­æ§‹å»ºä»£ç†çš„ç·¨æ’å™¨ï¼Œå¾è€Œè¼•é¬†è¨ªå• Azure ç”Ÿæ…‹ç³»çµ±ã€‚

## åƒè€ƒè³‡æ–™

## ä¸Šä¸€èª²

[AI ä»£ç†èˆ‡ä»£ç†ä½¿ç”¨æ¡ˆä¾‹ç°¡ä»‹](../01-intro-to-ai-agents/README.md)

## ä¸‹ä¸€èª²

[ç†è§£ä»£ç†è¨­è¨ˆæ¨¡å¼](../03-agentic-design-patterns/README.md)

**å…è²¬è²æ˜**ï¼š  
æœ¬æ–‡ä»¶ä½¿ç”¨ AI ç¿»è­¯æœå‹™ [Co-op Translator](https://github.com/Azure/co-op-translator) é€²è¡Œç¿»è­¯ã€‚å„˜ç®¡æˆ‘å€‘åŠªåŠ›ç¢ºä¿æº–ç¢ºæ€§ï¼Œä½†è«‹æ³¨æ„ï¼Œè‡ªå‹•ç¿»è­¯å¯èƒ½åŒ…å«éŒ¯èª¤æˆ–ä¸æº–ç¢ºä¹‹è™•ã€‚æ‡‰ä»¥åŸå§‹èªè¨€çš„æ–‡ä»¶ç‚ºæ¬Šå¨ä¾†æºã€‚å°æ–¼é—œéµè³‡è¨Šï¼Œå»ºè­°å°‹æ±‚å°ˆæ¥­äººå·¥ç¿»è­¯ã€‚æˆ‘å€‘å°å› ä½¿ç”¨æœ¬ç¿»è­¯è€Œç”¢ç”Ÿçš„ä»»ä½•èª¤è§£æˆ–éŒ¯èª¤è§£é‡‹æ¦‚ä¸è² è²¬ã€‚